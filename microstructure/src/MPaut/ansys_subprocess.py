import shutil
import pathlib
import logging
import re
import numpy as np
import tempfile
import io
import warnings
        
class AnsysMeshGenerator:
    """Class for creating RVE meshes from VoxSM output files."""
    
    def __init__(self, mapdl):
        """Create a mesh generator object.
        
        Parameters
        ----------
        mapdl : PyMAPDL Object
            MAPDL instance (local or remote) for running APDL commands.
        """
        self.mapdl = mapdl
        
        self.mesh_info = {'element_types': set(), 'materials': set(), 'components': set()}
        
        self.logger = logging.getLogger('AnsysMeshGenerator')
        self.logger.setLevel(logging.DEBUG)
        self.log_fh = logging.FileHandler('ansys_mesh.log', mode='w')
        self.log_fh.setLevel(logging.DEBUG)
        self.logger.addHandler(self.log_fh)
        
    def _create_and_upload_temp_file(self, array, fmt, filename_prefix='tmp'):
        # create a temporary directory and write nodes/element data to file 
        # in that directory (we cannot just use a temporary file because 
        # PyMAPDL also need to access the file which seems to not work properly
        # on Windows see: https://stackoverflow.com/a/57015383 )
        with tempfile.TemporaryDirectory() as td:
            fp = pathlib.Path(td, filename_prefix + '.inp')
            np.savetxt(fp, array, fmt, newline='\n')
            # upload file to Ansys APDL server
            filename_on_server = self.mapdl.upload(fp, progress_bar=False)
        return filename_on_server
        
    def _create_nodes(self, file):
        # convert nodes file to format compatible to be read using NREAD command
        nodes = np.loadtxt(file.absolute(), delimiter=',', usecols=(1,2,3,4))
        filename_on_server = self._create_and_upload_temp_file(nodes, fmt='%8d' + '%20.12E' * 3)
        # read the file using NREAD
        self.mapdl.nread(filename_on_server, mute=True)
                
    def _create_gb_prisms(self, file):
        # TODO grain bondary prisms use elements with 20 nodes
        # currently, the _create_elements method does not support this
        raise NotImplementedError("grain boundary elements are not supported yet")
        with tempfile.TemporaryDirectory() as td:
            # copy grain bondary prism input file to temporary directory and
            # append the definition of a single component
            # this way we can just reuse the _create_elements() method for the 
            # grain boundary elements files
            new_file = pathlib.Path(td) / file.name
            shutil.copy(file, new_file)
            with open(new_file, 'a') as f:
                f.write("CM,c_0,Elem")
            return self._create_elements(new_file, nnodes=8)
    
    def _process_subblock(self, subblock, cm_elems, active_material_type,
                          active_elem_type, elem_counter_subblock, elem_counter_block,
                          nnodes=4):
        # process block -> create elements
        # get filestream of current block for loading the data in numpy
        f_handler = io.StringIO(subblock)

        with warnings.catch_warnings():
            # suppress warnings that appear when the considered subblock contains
            # only comments
            warnings.simplefilter("ignore")
            elem_dat = np.genfromtxt(f_handler, delimiter=',', comments='!', 
                                 usecols=range(1,nnodes+1))
        f_handler.close()
        if len(elem_dat) > 0:
            if elem_dat.ndim == 1:
                # the following code assumes elem_dat to be a 2D array
                elem_dat = elem_dat[np.newaxis]
            # create input array in the format required by EREAD command
            # I, J, K, L, M, N, O, P, MAT, TYPE, REAL, SECNUM, ESYS, IEL,
            r0 = elem_counter_subblock   # start of current block
            r1 = elem_counter_subblock+elem_dat.shape[0] # end of current block
            
            cm_elems[r0:r1,:elem_dat.shape[1]] = elem_dat      # I, J, K, L, M, N, O, P
            cm_elems[r0:r1,8] = active_material_type           # MAT
            cm_elems[r0:r1,9] = active_elem_type               # TYPE
            cm_elems[r0:r1,10] = 1                             # REAL
            cm_elems[r0:r1,11] = 1                             # SECNUM
            cm_elems[r0:r1,12] = 0                             # ESYS
            cm_elems[r0:r1,13] = elem_counter_block + np.arange(r0, r1)             # IEL                    
            
            elem_counter_subblock += elem_dat.shape[0]
            
        return elem_counter_subblock
        
        
    def _create_elements(self, file, nnodes=4):
        """Parse the input file and generate an element mesh.
        
        The function can parse element creation files generated by VoxSM which
        include the definition of material numbers, element types, elements 
        and components.
        
        The file is processed by splitting the input data into blocks of 
        element creation commands (e, ...) which are seperated by commands
        setting the element type (type, ...), material type (Mat, ...) or
        defining mesh components (esel,none followed by <elements> followed by
        CM,...,Elem).
        
        For each extracted element block the new elements are defined by 
        creating a temporary elements file with the correct type and material
        numbers and reading this file using the APDL EREAD command.
        
        The function also takes care of defining mesh components.
        

        Parameters
        ----------
        file : pathlib.Path
            Path to the elements file to process.
        nnodes : int
            Number of nodes defining the element (used for parsing the elemnts
            input file using numpy)

        Returns
        -------
        res : dict
            Dict with sets of 'element_type', 'materials' and 'components'
            defined in the mesh

        """
        # split element file wherever new element type, material numbers or 
        # components are defined
        active_elem_type = None
        active_material_type = None
        block_start = 0
        
        with open(file) as elem_file:
            dat = elem_file.read()
        
        # search for blocks seperated CM commands
        cm_matches = re.finditer(r"^CM,(?P<cname>\w+),Elem", dat, re.MULTILINE)

        elem_counter_block = 1 # index of the next introduced element (number of current elements - 1)
        cm_elems = None
        
        # keep track of defined element types and components
        for cm in cm_matches:
            # create elements for the previous block (up to the current match)
            block_end = cm.start() # (sic)
            block = dat[block_start:block_end]
            
            # find number of elements in current component block to preallocate
            # numpy array for elements definition
            n_block_elems = len(re.findall(r"^e,", block, re.MULTILINE))
            cm_elems = np.zeros((n_block_elems, 14))
            
            sub_matches = re.finditer(r"^(type,(?P<elem_type>\d+))|"
                                      r"(Mat,(?P<mat_type>\d+))|"
                                      r"(esel,none)", 
                                      block, re.MULTILINE)
            
            subblock_start = 0
            elem_counter_subblock = 0
            
            # find subblocks of constant material number or element type 
            # in the current block
            for sm in sub_matches:
                subblock_end = sm.start()
                subblock = block[subblock_start:subblock_end]
            
                elem_counter_subblock = self._process_subblock(subblock, cm_elems,
                                                      active_material_type, 
                                                      active_elem_type, 
                                                      elem_counter_subblock, 
                                                      elem_counter_block,
                                                      nnodes)
                
                subblock_start = sm.end() # (sic)
                
                # change of element or material type defines new block
                if sm['elem_type'] is not None:
                    # set new active element type for subsequent elements
                    active_elem_type = int(sm['elem_type'])
                    self.mesh_info['element_types'].add(active_elem_type)
                elif sm['mat_type'] is not None:
                    # set new active material type for subsequent elements
                    active_material_type = int(sm['mat_type'])
                    self.mesh_info['materials'].add(active_material_type)
                else:   # esel command
                    assert 'esel,none' in sm.group(), "Match did not contain 'esel,none'. This should not happen."
                    # deselect all elements
                    self.mapdl.esel('NONE', mute=True)
                    
            # process last subblock up to the start of the next block
            subblock = block[subblock_start:]
            elem_counter_subblock = self._process_subblock(subblock, cm_elems,
                                        active_material_type, 
                                        active_elem_type, 
                                        elem_counter_subblock, 
                                        elem_counter_block,
                                        nnodes)
            assert cm_elems[-1,-1] == elem_counter_block + elem_counter_subblock - 1, "last index of defined elements in subblock did not match expected index"
                    
            fname_srv = self._create_and_upload_temp_file(cm_elems, 
                                                          fmt='%8d' * 14)
            # # read the file using EREAD
            self.mapdl.eread(fname_srv, mute=True)
            
            # define component for all previously selected elements
            self.mapdl.cm(cm['cname'], 'ELEM', mute=True)
            self.mesh_info['components'].add(cm['cname'])
            
            # increment counter of globally defined elements
            elem_counter_block += elem_counter_subblock
    
            # remember start of next block for later
            block_start = cm.end() # (sic)
            
    def _create_components(self, file, keepshells):
        with open(file) as comp_file:
            dat = comp_file.read()
            
        reg = r"^type,(?P<elem_type>\d+)$"
        elem_type_defs = re.findall(reg, dat, re.MULTILINE)
        if not len(elem_type_defs) == 1:
            raise NotImplementedError("Parser can only handle exactly one element type definition in components file."\
                                      f"The given file at {file} contains {len(elem_type_defs)} definitions.")
        self.mapdl.type(int(elem_type_defs[0]), mute=True)

            
        reg = r"^CMsel,s,(?P<comp_name>\w+)\s*"\
              r"^Mat,(?P<mat_number>\d+)\s*"\
              r"^FVmesh,keepShells\s*"\
              r"^esel,r,type,,1\s*"\
              r"^CM,(?P<vol_comp_name>\w+),Elem\s*"
        matches = re.finditer(reg, dat, re.MULTILINE)
                    
        for i, m in enumerate(matches, 1):
            self.logger.debug(f"Creating volume mesh for component {i} (name = {m['comp_name']})")
            self.mapdl.cmsel("s", m['comp_name'], mute=True)
            mat_number = int(m['mat_number'])
            self.mesh_info['materials'].add(mat_number)
            self.mapdl.mat(mat_number, mute=True)
            self.mapdl.fvmesh(int(keepshells), mute=True)
            self.mapdl.esel("r", "type", "", 1, mute=True)
            self.mapdl.cm(m['vol_comp_name'], "Elem", mute=True)
        
    
    def _check_element_definitions(element_types, files):
        # check whether an element type definition has been provided for all 
        # element types that are present in the mesh
        ref_elem_types = set()
        for file in files:
            if file is not None:
                with open(file) as ef:
                    data = ef.read()
                    types = re.findall(r"^(type,(?P<elem_type>\d+))", data, re.MULTILINE)
                    ref_elem_types = ref_elem_types.union([int(t[1]) for t in types])
        
        if not ref_elem_types.issubset(set(element_types.keys())):
            diff = ref_elem_types - set(element_types.keys())
            raise RuntimeError(f"elements with type indices {diff} would be "
                               "created in the mesh but no element type for "
                               "the given type indices was defined.")
            
    def create_mesh_from_VoxSM_output(self, voxsm_output_path, options={}):
        """Convencience wrapper for creating a database from VoxSM output files.
        
        This function parses the given output path with VoxSM output files 
        (``_main.win``, ``1_nodes.win``, etc.) to automatically create a mesh
        for further simulations in APDL.
        The meshing options are read from ``_main.win``.
        
        Some options can also be overwritten using the options dictionary

        Parameters
        ----------
        voxsm_output_path : TYPE
            DESCRIPTION.

        Returns
        -------
        None.

        """
        voxsm_output_path = pathlib.Path(voxsm_output_path)
        if not voxsm_output_path.exists():
            raise FileNotFoundError(f"could not find VoxSM output path at {voxsm_output_path}")
            
        # look for nodes and elements files at given path
        nodes_file = voxsm_output_path / '1_nodes.win'
        if not nodes_file.exists():
            raise FileNotFoundError(f"could not find nodes file at given VoxSM output path {voxsm_output_path}")
        gb_prism_file = next(voxsm_output_path.glob('*_GB_Prisms.win'), None)
        try:
            elements_file = next(voxsm_output_path.glob('*_SHELL_GB_RVE.win'))
        except StopIteration:
           raise FileNotFoundError(f"could not find elements file at given VoxSM output path {voxsm_output_path}")
        try:
            components_file = next(voxsm_output_path.glob('*_CMs_mesh.win'))
        except StopIteration:
           raise FileNotFoundError(f"could not find components file at given VoxSM output path {voxsm_output_path}")
        
        
        # look for parameters in _main.win file
        main_file = voxsm_output_path / '_main.win'
        if not main_file.exists():
            raise FileNotFoundError(f"could not find main file at given VoxSM output path {voxsm_output_path}")
            
        # parse main file to determine meshing options
        with open(main_file) as f:
            data = f.read()
            
        # find element types
        reg = r"^et,(?P<element_index>\d+),(?P<element_type>\w+)"
        matches = re.finditer(reg, data, re.MULTILINE)
        element_types = {int(m['element_index']): m['element_type'] 
                                                       for m in matches}
        
        # find output filename
        if not 'db_filename' in options:
            # determine output filename from VoxSM file
            reg = r"structFileName = '(?P<db_filename>[#\w-]+)'"
            res = re.search(reg, data)
            
            if res is not None:
                output_db_filename = res['db_filename'] + ".db"
            else:
                # use default in case no filename is found in the file
                output_db_filename = 'mesh.db'
        else:
            output_db_filename = options['db_filename']
            
        # find keepshells parameter
        if not 'keepshells' in options:
            # determine output filename from VoxSM file
            reg = r"keepShells = (?P<keepshells>[01])"
            res = re.search(reg, data)
            
            if res is not None:
                keepshells = res['keepshells'] == '1'
            else:
                # default in case parameter is not set in the file
                keepshells = False
        else:
            keepshells = options['keepshells']
                
        # find length of RVE
        reg = r"L(?P<axis>[xyz])? = (?P<L>[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)"
        res = re.findall(reg, data)
        if len(res) == 1:
            dims = {'L': float(res[0][1])}
        elif len(res) == 3:
            dims = {f'L{r[0]}': float(r[1]) for r in res}
        else:
            raise RuntimeError(f"could not read dimensions of RVE from main file at {main_file}")
    
        return self.create_mesh_db(nodes_file, elements_file, components_file,
                            gb_prism_file=gb_prism_file, 
                            element_types=element_types,
                            db_filename=output_db_filename,
                            rve_dims=dims,
                            keepshells=keepshells)
        
    def _check_file_existence(nodes_file, elements_file, components_file, 
                              gb_prism_file):
        node_path = pathlib.Path(nodes_file)
        if not node_path.exists():
            raise FileNotFoundError(f"Could not find node file at {node_path.absolute()}")
            
        elem_path = pathlib.Path(elements_file)
        if not elem_path.exists():
            raise FileNotFoundError(f"Could not find node file at {elem_path.absolute()}")
            
        comp_path = pathlib.Path(components_file)
        if not comp_path.exists():
            raise FileNotFoundError(f"Could not find node file at {comp_path.absolute()}")
        
        if gb_prism_file is not None:
            gb_prism_path = pathlib.Path(gb_prism_file)
        else:
            gb_prism_path = None
        
        return node_path, elem_path, comp_path, gb_prism_path
        
    def create_mesh_db(self, nodes_file, elements_file, components_file, 
                       gb_prism_file=None,
                       element_types={}, db_filename='mesh.db', rve_dims={'L': 3.2e-5},
                       keepshells=False):
        """Create an APDL database file with the definition of a mesh based
        on output files from VoxSM
        

        Returns
        -------
        None.

        """
        node_path, elem_path, comp_path, gb_prism_path = AnsysMeshGenerator._check_file_existence(nodes_file, elements_file, components_file, gb_prism_file)
        
        AnsysMeshGenerator._check_element_definitions(element_types, 
                                                      [elem_path, gb_prism_path])
        
        if not db_filename.endswith('.db'):
            raise ValueError("Database filename must end in .db")        
        
        self.logger.debug('creating mesh database')
        # ---------- header ----------
        self.mapdl.finish(mute=True)
        self.mapdl.clear(mute=True)
        self.mapdl.run("/Filname, mesh", mute=True)
        self.mapdl.prep7(mute=True)
        
        # create element types according to specified type dict
        for n, typ in element_types.items():
            self.mapdl.et(n, typ, mute=True)
            
        self.mapdl.real(1, mute=True)  #Real(1)= Shell thickness (GB)
        self.mapdl.mopt("TetExpnd", 2, mute=True)  #< 3( )
        self.mapdl.shpp("silent", "on", mute=True)
        self.mapdl.mshmid(2, mute=True)  #no Midnodes, prevent meshing-errors.  -> add later( )

        # ---------- input ----------
        # store size (=length) of RVE in the three axes
        for axis, length in rve_dims.items():
            self.mapdl.run(f"{axis} = {length}", mute=True)  # L-Box
        # create nodes
        res = self._create_nodes(node_path)
        
        # create grain boundary prisms
        if gb_prism_file is not None:
            cms = self._create_gb_prisms(gb_prism_path)
            
        # create elements
        self._create_elements(elem_path)
        
        # create componenents (particles)
        self._create_components(comp_path, keepshells)
        # ---------- end ----------
        self.mapdl.esel("s", "type", "", 3)  #RVE-Boundary-Elements
        self.mapdl.esel("a", "type", "", 2)  #GB-Shells
        self.mapdl.edele("all")  #delete selected Elements
        self.mapdl.esel("s", "type", "", 1)  #all
        self.mapdl.emid("add")  #add Midnodes to all (sel.) Elements
        self.mapdl.etdele(2, 6)  #needed DOFs only( ), delete '2-6'
        self.mapdl.allsel()
        self.mapdl.save(db_filename.split('.')[0], "db", "model")
    
        self.logger.debug('finished creating mesh database')
        
        return self.mesh_info
