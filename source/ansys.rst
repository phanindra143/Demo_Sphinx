RVE simulation
##############

The meshes generated by VoxSM serve as input for various material property 
simulations in ``ANSYS`` which have originally been implemenented using the 
``ANSYS`` Parametric Design Language (``APDL``).
To enable automation of the simulations the 
`PyMAPDL <https://mapdldocs.pyansys.com/>`_ package is used, which provides 
a python interface to the ``ANSYS APDL``.

Mesh generation using PyMAPDL
=============================
  
In principle, it is possible to just load the ``VoxSM`` output files (see: 
:ref:`VoxSM output files`) directly with ``PyMAPDL``, e.g. by the following 
commands:

.. code:: python

    >>> from ansys.mapdl.core import launch_mapdl
    >>> mapdl = launch_mapdl()
    >>> mapdl.input('_main.win') # generate mesh for simulation in Ansys

However, at the time of this writing, the ``mapdl.input()`` command seems to 
be a bit buggy (see `here <https://github.com/pyansys/pymapdl/issues/385>`_ 
and `here <https://github.com/pyansys/pymapdl/issues/380>`_) so a different 
way of preparing the mesh for simulation with ANSYS was implemented.

The :class:`~MPaut.ansys_subprocess.AnsysMeshGenerator` class provides methods 
to generate a mesh by passing it the node and element files that were created 
by VoxSM. The files will be parsed in python and the program will pass the 
appropriate commands for node and element generation on to ``PyMAPDL``.

.. code:: python

    from ansys.mapdl import core as pymapdl
    from MPaut import ansys_subprocess
    
    # launch MAPDL instance
    mapdl = pymapdl.launch_mapdl()
    
    # create a mesh generator object by passing it an MAPDL instance
    mesh_gen = ansys_subprocess.AnsysMeshGenerator(mapdl)
    
    # specify the files that were output by VoxSM
    node_file = 'output/1_nodes.win'
    elem_file = 'output/2_SHELL_GB_RVE.win'
    comp_file = 'output/3_CMs_mesh.win'
    
    # define the element types
    element_types = {1: "solid187", 2: "SHELL157", 3: "SHELL157"}
    
    # run the mesh generation
    mesh_gen.create_mesh_db(node_file, elem_file, comp_file, element_types=element_types)


In comparison to the old way of just executing the ``_main.win`` file with 
``APDL``, using ``PyMAPDL`` offers a lot more flexibility for the mesh 
generation. For example, you could pass different meshing options to ``APDL`` 
or redefine the element types by just setting the appropriate parameters, all 
without having to manually edit the original input files.

For convenience, the method 
:func:`~MPaut.ansys_subprocess.AnsysMeshGenerator.create_mesh_from_VoxSM_output` 
was added which tries to determine the necessary files, element types and 
meshing options automatically from a folder containing VoxSM output files.

.. code:: python

    from ansys.mapdl import core as pymapdl
    from MPaut import ansys_subprocess
    
    # launch MAPDL instance
    mapdl = pymapdl.launch_mapdl()    
    
    # create a mesh generator object by passing it an MAPDL instance
    mesh_gen = ansys_subprocess.AnsysMeshGenerator(mapdl)
     	
    # specify path to folder with VoxSM output files ('_main.win', '1_nodes.win', '2_SHELL_GB_RVE.win', etc.)
    voxsm_data_folder = 'output'
     	
    # the mesh is generated with options read from the files in the given folder
    mesh_gen.create_mesh_from_VoxSM_output(voxsm_data_folder)

Now you can use ``PyMAPDL`` to create plots for the different phases
in the RVE interactively, for example:

.. code:: python

    # select elements with material number 4 and create a plot
    mapdl.esel(item='mat', vmin=4, vmax=4)
    mapdl.eplot()
    
    # select elements with material number 10 and create another plot
    mapdl.esel(item='mat', vmin=10, vmax=10)
    mapdl.eplot()
    

.. figure:: images/zta_phase_1.PNG
  :width: 400
  
.. figure:: images/zta_phase_2.PNG
  :width: 400

The generated meshes can be used to run various types of microstructure 
simulations described below:

- :ref:`elasticity-sim` 
- :ref:`thermal-sim`
- :ref:`electrical-sim`

Running PyMAPDL remotely
========================
With the new Ansys release ``2021R1`` it is possible to `run APDL commands remotely with PyMAPDL <https://github.com/pyansys/pymapdl#launching-manually-or-connecting-to-a-remote-instance>`_.
This means you can do simulations from any workstation without the need for
having Ansys installed locally.

To use this feature, first launch Ansys on one of the workstations (currently 
``ISC0123`` or ``BAY3016``) using the following command in the windows command 
line::

    start "MAPDL" "%ANSYS211_DIR%\bin\winx64\ANSYS211.exe" -port 50052 -grpc -smp

.. note::
    The ``-smp`` options seems to be necessary for the simulations to work 
    correctly.

Find out the ip address of the workstation using::

    ipconfig
    
From a different computer in the network you can now connect to the remote
APDL instance using:

.. code:: python

    >>> from ansys.mapdl.core import Mapdl
    >>> ip = '<ip-from-above>'
    >>> mapdl = Mapdl(ip=ip, port=50052, request_instance=False)

You can use the created ``mapdl`` instance to run APDL commands on the 
local machine. However, note that there is an additional overhead due to the
network communication with the remote server.

Material property simulation
============================

The sections below explain how to you can perform simulations of elastic, 
thermal and electrical properties using ``PyMAPDL``.

.. _elasticity-sim:

Elasticity properties 
---------------------
The class :py:class:`MPaut.ansys_simulations.ELCsSimulator` can be used to 
calculate mechanical properties of an RVE. The simulation will perform six load 
steps, applying a small displacement for each face of the RVE cube and 
computing the resulting stress and strain tensors

.. math::
    \sigma^i =  \begin{bmatrix}
                \sigma^i_{11} \\ 
                \sigma^i_{22} \\ 
                \sigma^i_{zz} \\
                \sigma^i_{23} \\
                \sigma^i_{13} \\
                \sigma^i_{12}
                \end{bmatrix}, \hspace{1cm}
    \epsilon^i =  \begin{bmatrix}
                \epsilon^i_{11} \\ 
                \epsilon^i_{22} \\ 
                \epsilon^i_{33} \\
                \epsilon^i_{23} \\
                \epsilon^i_{13} \\
                \epsilon^i_{12}
                \end{bmatrix}
    \hspace{1cm} \text{ for } i \in \{1, ..., 6\}.
    
From those we compute the elasticity tensor

.. math::

    C = \begin{bmatrix}
     C_{11}  & C_{12} & C_{13} & C_{14} & C_{15}  & C_{16} \\
     C_{12}  & C_{22} & C_{23} & C_{24} & C_{25}  & C_{26} \\
     C_{13}  & C_{23} & C_{33} & C_{34} & C_{35}  & C_{36} \\
     C_{14}  & C_{24} & C_{34} & C_{44} & C_{45}  & C_{46} \\
     C_{15}  & C_{25} & C_{35} & C_{45} & C_{55}  & C_{56} \\
     C_{16}  & C_{26} & C_{36} & C_{46} & C_{56}  & C_{66} 
    \end{bmatrix}.

Using the Voigt-Reuss-Hill approximation we get estimates for the modulus 
of elasticity :math:`E`, poisson ratio :math:`\nu`, bulk modulus :math:`K` and 
shear modulus :math:`G`.

To run the simulation, you first need to generate an APDL database with the 
definition of the mesh (see: :ref:`Mesh generation using PyMAPDL`). Pass this
database file to the :py:meth:`~MPaut.ansys_simulations.ELCsSimulator.simulate` 
function, together with a dictionary containing the material numbers of the 
different phases present in the mesh and their respective elastic properties 
(elastic modulus and poisson ratio)

.. code:: python

    >>> sim = ansys_simulations.ELCsSimulator(mapdl)
    >>> mesh_db_filename = 'mesh.db'
    >>> phase_mat_params = { 'WC': {'phase_number': 1, 'emod': 650, 'pois': 0.22}, \
    >>>                      'Co': {'phase_number': 2, 'emod': 210, 'pois': 0.31} }
    >>> res = sim.simulate(mesh_db_filename, phase_mat_params)
    
In addition, you can pass several options that control the simulation process, 
e.g. the tolerance of the solver

.. code:: python

    >>> options = {'solver_tolerance': 1.0e-6}
    >>> res = sim.simulate(mesh_db_filename, phase_mat_params, options=options)
    
The simulation result object is a dictionary containing the resulting stiffness
tensor :math:`C`

.. code:: python

    >>> res['stiffness_tensor']
    array([[ 4.16550879e+02,  1.56801278e+02,  1.56470828e+02,
        -9.69997794e-05, -2.83660721e-01,  8.21835586e-01],
       [ 1.56801278e+02,  4.19397537e+02,  1.56042443e+02,
         6.80345545e-01,  1.55553122e-01,  8.47908390e-01],
       [ 1.56470828e+02,  1.56042443e+02,  4.11905389e+02,
         3.43401270e-01,  1.69282831e-01, -2.92501278e-03],
       [-9.69997794e-05,  6.80345545e-01,  3.43401270e-01,
         1.26146349e+02,  3.02741536e-01,  2.07973627e-01],
       [-2.83660721e-01,  1.55553122e-01,  1.69282831e-01,
         3.02741536e-01,  1.26132703e+02,  2.67003225e-01],
       [ 8.21835586e-01,  8.47908390e-01, -2.92501278e-03,
         2.07973627e-01,  2.67003225e-01,  1.28928387e+02]])
         
and the elastic constants from the Voigt-, Reuss- and Hill-averages

.. code:: python

    >>> res['voigt_avg']
    {'E': 326.94764852700325,
     'G': 128.14410516130164,
     'K': 242.94254493113144,
     'nu': 0.2757030380580412}
    >>> res['reuss_avg']
    {'E': 326.882677416648,
     'G': 128.1157440960857,
     'K': 242.9255016007859,
     'nu': 0.27573187715121406}
    >>> res['hill_avg']
    {'E': 326.9151629718256,
     'G': 128.1299246286937,
     'K': 242.93402326595867,
     'nu': 0.2757174576046276}

     
If required, you also have access to several properties like the stresses and 
strains in each load step or the volume fraction in the RVE. We refere to the
documentation of the :py:meth:`~MPaut.ansys_simulations.ELCsSimulator.simulate` 
function for the full details.
     
Example: Elasticity simulation for ZTA microstructures
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
This example continues from the previous one (see: :ref:`Example: Meshing of ZTA microstructure`)
and assumes the VoxSM output files are located in the subdirectories of 
``output/zta_20``. The example first generates an Ansys mesh from the VoxSM 
output and stores it in a database. Then it runs the simulation and stores the
result in a dictionary. At the end, all of the results are written to a file
which can be used for further processing (plotting etc.).

.. literalinclude:: examples/examples_zta_ansys_sim.py

For a detailed description of effect of different volume fractions on the elastic properties,
see the documentation :ref:`volume_fraction_mesh-reference-label`.

.. _thermal-sim:

Thermal properties 
------------------
- TODO :py:class:`MPaut.ansys_simulations.ThermalConductivitySimulator`
- TODO :py:class:`MPaut.ansys_simulations.ThermalStressSimulator`

.. _electrical-sim:

Electrical properties 
---------------------
- TODO

If you want to implement your own simulator for further material properties
you can extend the base class :py:class:`MPaut.ansys_simulations.Simulator`
which provides a basic framework for simulations.